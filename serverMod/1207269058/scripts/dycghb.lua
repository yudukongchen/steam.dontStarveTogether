local _k4Gx = require "widgets/widget" local _emAi = require "widgets/image" local _ofsr = require "widgets/text" local _LY5x = SimpleHealthBar local _DmtI = _LY5x.DYCModRequire local _93nW = _DmtI( "dycrgbacolor" ) local _O6Mt = function(_koqU) return math.min(math.max(_koqU, 0x0), 0x1) end local _PqNO = function(_U2QQ, _ziAK, _EGpF) return _U2QQ + (_ziAK - _U2QQ) * _EGpF end local _J9M7 = function(_ZRTq, _QTSi) for _Kg7a, _ZIMu in pairs(_ZRTq) do if _ZIMu == _QTSi then return true end end return false end local _kqNL = function(_GMi0, _DMri) if not _J9M7(_GMi0, _DMri) then table.insert(_GMi0, _DMri) end end local _QhTk = function(_Ls47, _Gx8a) for _kIgs, _kAV5 in pairs(_Ls47) do if _kAV5 == _Gx8a then return _kIgs end end end local _35us = function(_wbAm, _J2Xd) local _BKBC = _QhTk(_wbAm, _J2Xd) if _BKBC then table.remove(_wbAm, _BKBC) end end local _xXyG = Class(_k4Gx, function(_NPXX, _sMB8) _k4Gx._ctor(_NPXX, "DYC_SlicedImage" ) _NPXX.images = {} _NPXX.mode = "slice13" _NPXX.texScale = _sMB8.texScale or 0x1 _NPXX.width = 0x64 _NPXX.height = 0x64 _NPXX:SetTextures(_sMB8) end) function _xXyG:__tostring() return string.format( "%s (%s)" , self.name, self.mode) end function _xXyG:SetTextures(_GZQc) assert(_GZQc.mode) self.images = {} self.mode = _GZQc.mode if self.mode == "slice13" or self.mode == "slice31" then local _1woV = nil _1woV = self:AddChild(_emAi(_GZQc.atlas, _GZQc.texname.."_1.tex" )) _1woV.oriW, _1woV.oriH = _1woV:GetSize() _1woV.imgPos = 0x1 self.images[0x1] = _1woV _1woV = self:AddChild(_emAi(_GZQc.atlas, _GZQc.texname.."_2.tex" )) _1woV.oriW, _1woV.oriH = _1woV:GetSize() _1woV.imgPos = 0x2 self.images[0x2] = _1woV _1woV = self:AddChild(_emAi(_GZQc.atlas, _GZQc.texname.."_3.tex" )) _1woV.oriW, _1woV.oriH = _1woV:GetSize() _1woV.imgPos = 0x3 self.images[0x3] = _1woV if self.mode == "slice13" then assert(self.images[0x1].oriH == self.images[0x3].oriH, "Height must be equal!" ) assert(self.images[0x1].oriH == self.images[0x2].oriH, "Height must be equal!" ) else assert(self.images[0x1].oriW == self.images[0x3].oriW, "Width must be equal!" ) assert(self.images[0x1].oriW == self.images[0x2].oriW, "Width must be equal!" ) end return elseif self.mode == "slice33" then local _WAYK = nil for _1SyN = 0x1, 0x3 do for _K5JJ = 0x1, 0x3 do _WAYK = self:AddChild(_emAi(_GZQc.atlas, _GZQc.texname.."_".._1SyN.._K5JJ..".tex" )) _WAYK.oriW, _WAYK.oriH = _WAYK:GetSize() _WAYK.imgPos = _1SyN * 0xa + _K5JJ self.images[_1SyN * 0xa + _K5JJ] = _WAYK if _1SyN > 0x1 then assert(self.images[_1SyN * 0xa + _K5JJ].oriW == self.images[(_1SyN - 0x1) * 0xa + _K5JJ].oriW, "Width must be equal!" ) end if _K5JJ > 0x1 then assert(self.images[_1SyN * 0xa + _K5JJ].oriH == self.images[_1SyN * 0xa + _K5JJ - 0x1].oriH, "Height must be equal!" ) end end end return end error( "Mode not supported!" ) self:SetSize() end function _xXyG:SetSize(_gN5x, _cpro) _gN5x = _gN5x or self.width _cpro = _cpro or self.height if self.mode == "slice13" then local _hHaT = self.images[0x1] local _KCQT = self.images[0x2] local _mUlf = self.images[0x3] local _wPP6 = math.min(self.texScale, math.min(_gN5x / (_hHaT.oriW + _mUlf.oriW), _cpro / _hHaT.oriH)) local _9YO5 = _hHaT.oriW * _wPP6 local _qjnw = _mUlf.oriW * _wPP6 local _d112 = math.max(0x0, _gN5x - _9YO5 - _qjnw) _hHaT:SetSize(_9YO5, _cpro) _KCQT:SetSize(_d112, _cpro) _mUlf:SetSize(_qjnw, _cpro) local _4saM = (_9YO5 - _qjnw) / 0x2 local _e9Op = - _9YO5 / 0x2 - _d112 / 0x2 + _4saM local _Ae9y = _qjnw / 0x2 + _d112 / 0x2 + _4saM _hHaT:SetPosition(_e9Op, 0x0, 0x0) _KCQT:SetPosition(_4saM, 0x0, 0x0) _mUlf:SetPosition(_Ae9y, 0x0, 0x0) self.width = _9YO5 + _d112 + _qjnw self.height = _cpro elseif self.mode == "slice31" then local _bPAZ = self.images[0x1] local _TDnA = self.images[0x2] local _89yo = self.images[0x3] local _Kw77 = math.min(self.texScale, math.min(_cpro / (_bPAZ.oriH + _89yo.oriH), _gN5x / _bPAZ.oriW)) local _uNPT = _bPAZ.oriH * _Kw77 local _LYY4 = _89yo.oriH * _Kw77 local _TJaw = math.max(0x0, _cpro - _uNPT - _LYY4) _bPAZ:SetSize(_gN5x, _uNPT) _TDnA:SetSize(_gN5x, _TJaw) _89yo:SetSize(_gN5x, _LYY4) local _bAG4 = (_uNPT - _LYY4) / 0x2 local _Yp3L = - _uNPT / 0x2 - _TJaw / 0x2 + _bAG4 local _SxNK = _LYY4 / 0x2 + _TJaw / 0x2 + _bAG4 _bPAZ:SetPosition(0x0, _Yp3L, 0x0) _TDnA:SetPosition(0x0, _bAG4, 0x0) _89yo:SetPosition(0x0, _SxNK, 0x0) self.height = _uNPT + _TJaw + _LYY4 self.width = _gN5x elseif self.mode == "slice33" then local _NA45 = self.images local _3WbS = math.min(self.texScale, math.min(_gN5x / (_NA45[0xb].oriW + _NA45[0xd].oriW), _cpro / (_NA45[0xb].oriH + _NA45[0x1f].oriH))) local _cQ5W, hs, xs, ys = {}, {}, {}, {} _cQ5W[0x1] = _NA45[0xb].oriW * _3WbS _cQ5W[0x3] = _NA45[0xd].oriW * _3WbS _cQ5W[0x2] = math.max(0x0, _gN5x - _cQ5W[0x1] - _cQ5W[0x3]) hs[0x1] = _NA45[0xb].oriH * _3WbS hs[0x3] = _NA45[0x1f].oriH * _3WbS hs[0x2] = math.max(0x0, _cpro - hs[0x1] - hs[0x3]) xs[0x2] = (_cQ5W[0x1] - _cQ5W[0x3]) / 0x2 xs[0x1] = - _cQ5W[0x1] / 0x2 - _cQ5W[0x2] / 0x2 + xs[0x2] xs[0x3] = _cQ5W[0x3] / 0x2 + _cQ5W[0x2] / 0x2 + xs[0x2] ys[0x2] = (hs[0x1] - hs[0x3]) / 0x2 ys[0x1] = - hs[0x1] / 0x2 - hs[0x2] / 0x2 + ys[0x2] ys[0x3] = hs[0x3] / 0x2 + hs[0x2] / 0x2 + ys[0x2] for _yqXn = 0x1, 0x3 do for _0Gfj = 0x1, 0x3 do _NA45[_yqXn * 0xa + _0Gfj]:SetSize(_cQ5W[_0Gfj], hs[_yqXn]) _NA45[_yqXn * 0xa + _0Gfj]:SetPosition(xs[_0Gfj], ys[_yqXn], 0x0) end end self.width = _cQ5W[0x1] + _cQ5W[0x2] + _cQ5W[0x3] self.height = hs[0x1] + hs[0x2] + hs[0x3] end end function _xXyG:GetSize() return self.width, self.height end function _xXyG:SetTint(_D1zH, _DEzv, _Cvo6, _affl) for _33a7, _Irtu in pairs(self.images) do _Irtu:SetTint(_D1zH, _DEzv, _Cvo6, _affl) end end function _xXyG:SetClickable(_ETFI) for _CPUm, _rDgW in pairs(self.images) do _rDgW:SetClickable(_ETFI) end end local _awCz = Class(_k4Gx, function(_xPqQ, _C8Vt) _k4Gx._ctor(_xPqQ, "DYC_TextHealthbar" ) _xPqQ.text = _xPqQ:AddChild(_ofsr(NUMBERFONT, 0x14, "" )) _xPqQ.c1 = _C8Vt.c1 or "=" _xPqQ.c2 = _C8Vt.c2 or "#" _xPqQ.cnum = _C8Vt.cnum or 0xa _xPqQ.numCoeff = _C8Vt.numCoeff or 0x1 _xPqQ.percentage = 0x1 _xPqQ.fontSize = _C8Vt.fontSize or 0x14 _xPqQ.hbScale = _C8Vt.hbScale or 0x1 _xPqQ:SetPercentage() _xPqQ:SetHBScale() if _C8Vt.color then _xPqQ:SetTextColor(_C8Vt.color) end end) function _awCz:SetStrings(_kLu7, _FiLl, _HedT) _kLu7 = _kLu7 or self.c1; _FiLl = _FiLl or self.c2; _HedT = _HedT or self.cnum; _HedT = math.max(0x1, _HedT) self.c1 = _kLu7; self.c2 = _FiLl; self.cnum = _HedT; self:SetPercentage() end function _awCz:SetLength(_803W) _803W = _803W or self.cnum self.cnum = _803W self:SetPercentage() end function _awCz:SetPercentage(_LcOH) _LcOH = _LcOH or self.percentage _LcOH = math.max(0x0, math.min(_LcOH, 0x1)) self.percentage = _LcOH local _8tkH = self.c1 local _ALJ2 = self.c2 local _bN2F = self.cnum * self.numCoeff local _8my0 = "" for _vXRi = 0x1, _bN2F do if _LcOH == 0x0 or (_vXRi ~= 0x1 and _vXRi * 1.0 / _bN2F > _LcOH) then _8my0 = _8my0.._8tkH else _8my0 = _8my0.._ALJ2 end end self.text:SetString(_8my0) end function _awCz:SetFontSize(_15o6) _15o6 = _15o6 or self.fontSize self.fontSize = _15o6 self.text:SetSize(self.fontSize * self.hbScale) end function _awCz:SetHBScale(_tTAG) _tTAG = _tTAG or self.hbScale self.hbScale = _tTAG self:SetFontSize() end function _awCz:SetColor(_WDfA, _tnu0, _BWG3, _ISj4) _WDfA = _WDfA or 0x1 _tnu0 = _tnu0 or 0x1 _BWG3 = _BWG3 or 0x1 _ISj4 = _ISj4 or 0x1 if type(_WDfA) == "table" then _WDfA.r = _WDfA.r or _WDfA.x or _WDfA[0x1] or 0x1 _WDfA.g = _WDfA.g or _WDfA.y or _WDfA[0x2] or 0x1 _WDfA.b = _WDfA.b or _WDfA.z or _WDfA[0x3] or 0x1 _WDfA.a = _WDfA.a or _WDfA[0x1] or 0x1 self.text:SetColour(_WDfA.r, _WDfA.g, _WDfA.b, _WDfA.a) else self.text:SetColour(_WDfA, _tnu0, _BWG3, _ISj4) end end local _mHUW = Class(_k4Gx, function(_CcBY, _vGPd) _k4Gx._ctor(_CcBY, "DYC_GraphicHealthbar" ) _CcBY:SetScaleMode(_vGPd.isDemo and SCALEMODE_NONE or SCALEMODE_PROPORTIONAL) _CcBY:SetMaxPropUpscale(0x3e7) _CcBY.worldOffset = Vector3(0x0, 0x0, 0x0) _CcBY.screen_offset = Vector3(0x0, 0x0, 0x0) _CcBY.isDemo = _vGPd.isDemo _CcBY.bg = _CcBY:AddChild(_emAi(_vGPd.basic.atlas, _vGPd.basic.texture)) _CcBY.bg:SetClickable(_CcBY.isDemo or false) _CcBY.bg2 = _CcBY:AddChild(_emAi(_vGPd.basic.atlas, _vGPd.basic.texture)) _CcBY.bg2:SetClickable(_CcBY.isDemo or false) _CcBY.text = _CcBY:AddChild(_ofsr(NUMBERFONT, 0x14, "" )) _CcBY.healthReductions = {} _CcBY.style = "textonbar" _CcBY.showBg = true _CcBY.showBg2 = true _CcBY.showValue = true _CcBY.hp = 0x64 _CcBY.hpMax = 0x64 _CcBY.percentage = 0x1 _CcBY.opacity = 0x1 _CcBY.hbScale = 0x1 _CcBY.hbYOffset = 0x0 _CcBY.hbWidth = 0x78 _CcBY.hbHeight = 0x12 _CcBY.barMargin = {x1 = 0x3, x2 = 0x3, y1 = 0x3, y2 = 0x3, fixed = true} _CcBY.fontSize = 0x14 _CcBY.hrDuration = 0.8 _CcBY.screenWidth = 0x780 _CcBY.screenHeight = 0x438 _CcBY.bgColor = _93nW(0x1, 0x1, 0x1) _CcBY.bg2Color = _93nW(0x0, 0x0, 0x0) _CcBY.barColor = _93nW(0x1, 0x1, 0x1) _CcBY.hrColor = _93nW(0x1, 0x1, 0x1) _CcBY.preUpdateFn = nil _CcBY.onSetPercentage = nil _CcBY:SetData(_vGPd) _CcBY:SetOpacity() _CcBY:SetHBSize(0x78, 0x12) _CcBY:SetFontSize(0x14) _CcBY:StartUpdating() _CcBY:AddToTable() end) _mHUW.ghbs = {} function _mHUW:AddToTable() _kqNL(_mHUW.ghbs, self) end function _mHUW:SetData(_fonR) self.data = _fonR self.basicAtlas = _fonR.basic.atlas self.basicTex = _fonR.basic.texture self.bgAtlas = _fonR.bg and _fonR.bg.atlas self.bgTex = _fonR.bg and _fonR.bg.texture self.barAtlas = _fonR.bar and _fonR.bar.atlas self.barTex = _fonR.bar and _fonR.bar.texture self:SetBgSkn(_fonR.bgSkn) self:SetBarSkn(_fonR.barSkn) end function _mHUW:SetBgTexture(_ldfI, _IClU) self.bg:SetTexture(_ldfI, _IClU) self.bg2:SetTexture(_ldfI, _IClU) end function _mHUW:SetBgSkn(_1HyI) self.bgSknData = _1HyI or nil if self.bgSkn then self.bgSkn:Kill() self.bgSkn = nil end if self.bgSknData then self.bgSkn = self:AddChild(_xXyG(self.bgSknData)) self.bgSkn:SetClickable(self.isDemo or false) self.bgSkn:MoveToBack() self.showBg = false else self:SetBgTexture(self.bgAtlas or self.basicAtlas, self.bgTex or self.basicTex) self.showBg = true end if self.data and (self.data.bg2 or not self.data.bg) then self.showBg2 = true else self.showBg2 = false end self.bgColor = self.data and self.data.bg and self.data.bg.color or _93nW(0x1, 0x1, 0x1) self.bg2Color = self.data and self.data.bg2 and self.data.bg2.color or _93nW(0x0, 0x0, 0x0) end function _mHUW:SetBarSkn(_qXJj) self.barSknData = _qXJj or nil if self.bar then self.bar:Kill() self.bar = nil end if self.barSknData then self.bar = self:AddChild(_xXyG(self.barSknData)) self.bar:SetClickable(self.isDemo or false) self.bar:MoveToFront() self.text:MoveToFront() else self.bar = self:AddChild(_emAi(self.barAtlas or self.basicAtlas, self.barTex or self.basicTex)) self.bar:SetClickable(self.isDemo or false) self.bar:MoveToFront() self.text:MoveToFront() end end function _mHUW:SetBarTexture(_WtTV, _8OeU) if self.bar.SetTexture then self.bar:SetTexture(_WtTV, _8OeU) end end function _mHUW:SetValue(_cqfX, _HrVn, _IYSF) self.hp = _cqfX or self.hp self.hpMax = _HrVn or self.hpMax self.text:SetString(string.format( "%d/%d" , _cqfX, _HrVn)) self:SetPercentage(_cqfX / _HrVn, _IYSF) end function _mHUW:SetYOffSet(_NLwU, _v944) _NLwU = _NLwU or self.hbYOffset self.hbYOffset = _NLwU local _N2HH = self.screenWidth / 0x780 self:SetScreenOffset( - 0x5 * _N2HH, self.hbYOffset * (_v944 and self.hbScale or 0x1) * _N2HH) end function _mHUW:SetPercentage(_6GqV, _EBTG) local _8vGr = self.percentage _6GqV = _6GqV or self.percentage _6GqV = math.max(0x0, math.min(_6GqV, 0x1)) if _8vGr - _6GqV > 0.01 and not _EBTG and self.shown then self:DisplayHealthReduction(_8vGr, _6GqV) end self.percentage = _6GqV local _xymK, h = self:GetSize() _xymK = _xymK or 0x1 h = h or 0x1 local _Wl9B, barH = self:GetBarFullSize() local _eeGl, barVH = self:GetBarVirtualSize() local _79A8 = _Wl9B - _eeGl * (0x1 - _6GqV) local _Tkgj, oy = self:GetBarOffset() self.bar:SetSize(_79A8, barH) self.bar:SetPosition( - (_Wl9B - _79A8) / 0x2 + _Tkgj, oy, 0x0) if self.textHealthBar then self.textHealthBar:SetPercentage(_6GqV) end if self.onSetPercentage then self.onSetPercentage(self, _6GqV) end end function _mHUW:SetHBSize(_TH1b, _a9Tg) _TH1b = _TH1b or self.hbWidth _a9Tg = _a9Tg or self.hbHeight _TH1b = math.max(_TH1b, 0x0) _a9Tg = math.max(_a9Tg, 0x0) self.hbWidth = _TH1b self.hbHeight = _a9Tg _TH1b = _TH1b * self.hbScale _a9Tg = _a9Tg * self.hbScale self.bg:SetSize(_TH1b, _a9Tg) self.bg2:SetSize(math.max(_TH1b - 0x2, 0x0), math.max(_a9Tg - 0x2, 0x0)) if self.bgSknData and self.bgSkn then local _flGr, bgh = self:GetBgSknSize() self.bgSkn:SetSize(_flGr, bgh) local _efw7, oy = self:GetBgOffset() self.bgSkn:SetPosition(_efw7, oy, 0x0) end self:SetPercentage() self:SetYOffSet() if self.textHealthBar then self.textHealthBar:SetFontSize(self.hbHeight * 0x1) end end function _mHUW:SetFontSize(_XthC) _XthC = _XthC or self.fontSize self.fontSize = _XthC self.text:SetSize(self.fontSize * self.hbScale) local _2gD2, h = self:GetSize() _2gD2 = _2gD2 or 0x1 h = h or 0x1 if self.style == "textoverbar" then self.text:SetPosition(0x0, h / 0x2 + self.fontSize * self.hbScale * 0.35, 0x0) elseif self.style == "barovertext" then self.text:SetPosition(0x0, - h / 0x2 - self.fontSize * self.hbScale * 0.35, 0x0) else self.text:SetPosition(0x0, 0x0, 0x0) end end function _mHUW:SetHBScale(_afYE) _afYE = _afYE or self.hbScale self.hbScale = _afYE self:SetHBSize() self:SetFontSize() if self.textHealthBar then self.textHealthBar:SetHBScale(_afYE) end end function _mHUW:SetStyle(_bUXY) _bUXY = _bUXY or self.style if _bUXY == self.style then return end self.style = _bUXY self:SetFontSize() end function _mHUW:SetOpacity(_pwIZ) _pwIZ = _pwIZ or self.opacity self.opacity = _pwIZ local _GlKX = self.bgColor self.bg:SetTint(_GlKX.r, _GlKX.g, _GlKX.b, self.showBg and _pwIZ or 0x0) _GlKX = self.bg2Color self.bg2:SetTint(_GlKX.r, _GlKX.g, _GlKX.b, self.showBg and self.showBg2 and _pwIZ or 0x0) _GlKX = self.barColor self.bar:SetTint(_GlKX.r, _GlKX.g, _GlKX.b, _pwIZ) if self.bgSkn then self.bgSkn:SetTint(0x1, 0x1, 0x1, _pwIZ) end end function _mHUW:SetBarColor(_B2v2, _Hog2, _MDlz) _B2v2 = _B2v2 or 0x1 _Hog2 = _Hog2 or 0x1 _MDlz = _MDlz or 0x1 if type(_B2v2) == "table" then self.barColor.r = _B2v2.r or _B2v2.x or _B2v2[0x1] or 0x1 self.barColor.g = _B2v2.g or _B2v2.y or _B2v2[0x2] or 0x1 self.barColor.b = _B2v2.b or _B2v2.z or _B2v2[0x3] or 0x1 else self.barColor.r = _B2v2 self.barColor.g = _Hog2 self.barColor.b = _MDlz end self:SetOpacity() if self.textHealthBar then self.textHealthBar:SetColor(_B2v2, _Hog2, _MDlz) end end function _mHUW:SetTextColor(_cNqM, _e9a4, _lpfv, _yScS) _cNqM = _cNqM or 0x1 _e9a4 = _e9a4 or 0x1 _lpfv = _lpfv or 0x1 _yScS = _yScS or 0x1 if type(_cNqM) == "table" then _cNqM.r = _cNqM.r or _cNqM.x or _cNqM[0x1] or 0x1 _cNqM.g = _cNqM.g or _cNqM.y or _cNqM[0x2] or 0x1 _cNqM.b = _cNqM.b or _cNqM.z or _cNqM[0x3] or 0x1 _cNqM.a = _cNqM.a or _cNqM[0x1] or 0x1 self.text:SetColour(_cNqM.r, _cNqM.g, _cNqM.b, _cNqM.a) else self.text:SetColour(_cNqM, _e9a4, _lpfv, _yScS) end end function _mHUW:DisplayHealthReduction(_GHAL, _Ttaa) local _UKuW = self.bg2:AddChild(_emAi(self.basicAtlas, self.basicTex)) _UKuW:SetClickable(self.isDemo or false) local _961H, h = self:GetSize() _961H = _961H or 0x1 h = h or 0x1 local _IxVL, h2 = self:GetBarVirtualSize() local _f5VH = _IxVL * math.max(0x0, _GHAL - _Ttaa) local _kPMm = ((_Ttaa + _GHAL) / 0x2 - 0.5) * _IxVL local _XaEZ, oy = self:GetBarVirtualOffset() local _mxvf = self.data and self.data.hrUseBarColor and self.barColor or self.hrColor _UKuW:SetSize(_f5VH, h2) _UKuW:SetPosition(_kPMm + _XaEZ, oy, 0x0) _UKuW:SetTint(_mxvf.r, _mxvf.g, _mxvf.b, self.opacity) _UKuW.fadeTimer = self.hrDuration table.insert(self.healthReductions, _UKuW) end function _mHUW:AnimateIn(_dKPS) self.animHBWidth = self.hbWidth self.animIn = true self.animSpeed = _dKPS or 0x5 self:SetHBSize(0x0, self.hbHeight) end function _mHUW:AnimateOut(_Mq2E) self.animHBWidth = 0x0 self.animOut = true self.animSpeed = _Mq2E or 0x5 end function _mHUW:Kill() _35us(_mHUW.ghbs, self) _k4Gx.Kill(self) end function _mHUW:OnMouseButton(_Oo5o, _xHXa, _6AML, _W2Ae, ...) local _RXmU = _mHUW._base.OnMouseButton(self, _Oo5o, _xHXa, _6AML, _W2Ae, ...) if not _xHXa and _Oo5o == MOUSEBUTTON_LEFT then self.dragging = false end if not self.focus then return false end if self.isDemo and _xHXa and _Oo5o == MOUSEBUTTON_LEFT then self.dragging = true end return _RXmU end function _mHUW:GetSize() return self.bg:GetSize() end function _mHUW:GetBgMargin() local _fFKL, h = self:GetSize() _fFKL = _fFKL or 0x1 h = h or 0x1 local _KVE8 = self.bgSknData and self.bgSknData.margin or (self.data and self.data.bg and self.data.bg.margin) or {x1 = 0x0, x2 = 0x0, y1 = 0x0, y2 = 0x0, } local _Rd8Y = _KVE8.fixed and _KVE8.x1 or _KVE8.x1 * h local _dq36 = _KVE8.fixed and _KVE8.x2 or _KVE8.x2 * h local _TxZp = _KVE8.fixed and _KVE8.y1 or _KVE8.y1 * h local _nD3V = _KVE8.fixed and _KVE8.y2 or _KVE8.y2 * h return _Rd8Y, _dq36, _TxZp, _nD3V end function _mHUW:GetBarMargin() local _UUtl, h = self:GetSize() _UUtl = _UUtl or 0x1 h = h or 0x1 local _jLbZ = self.barSknData and self.barSknData.margin or (self.data and self.data.bar and self.data.bar.margin) or self.barMargin local _diyj = _jLbZ.fixed and _jLbZ.x1 or _jLbZ.x1 * h local _OtOL = _jLbZ.fixed and _jLbZ.x2 or _jLbZ.x2 * h local _dYs3 = _jLbZ.fixed and _jLbZ.y1 or _jLbZ.y1 * h local _CYHF = _jLbZ.fixed and _jLbZ.y2 or _jLbZ.y2 * h return _diyj, _OtOL, _dYs3, _CYHF end function _mHUW:GetBarVirtualMargin() local _8Eut, h = self:GetSize() _8Eut = _8Eut or 0x1 h = h or 0x1 local _87GM = self.barSknData and self.barSknData.vmargin or (self.data and self.data.bar and self.data.bar.vmargin) or (self.barSknData and self.barSknData.margin) or (self.data and self.data.bar and self.data.bar.margin) or self.barMargin local _MY00 = _87GM.fixed and _87GM.x1 or _87GM.x1 * h local _CtYg = _87GM.fixed and _87GM.x2 or _87GM.x2 * h local _bjU5 = _87GM.fixed and _87GM.y1 or _87GM.y1 * h local _2UrA = _87GM.fixed and _87GM.y2 or _87GM.y2 * h return _MY00, _CtYg, _bjU5, _2UrA end function _mHUW:GetBgOffset() local _Tnmy, mx2, my1, my2 = self:GetBgMargin() return(_Tnmy - mx2) / 0x2, (my1 - my2) / 0x2 end function _mHUW:GetBarOffset() local _kas6, mx2, my1, my2 = self:GetBarMargin() return(_kas6 - mx2) / 0x2, (my1 - my2) / 0x2 end function _mHUW:GetBarVirtualOffset() local _mYmO, px2, py1, py2 = self:GetBarVirtualMargin() return(_mYmO - px2) / 0x2, (py1 - py2) / 0x2 end function _mHUW:GetBgSknSize() local _qR1g, h = self:GetSize() _qR1g = _qR1g or 0x1 h = h or 0x1 local _LWGZ, mx2, my1, my2 = self:GetBgMargin() return math.max(_qR1g - _LWGZ - mx2, 0x2), math.max(h - my1 - my2, 0x2) end function _mHUW:GetBarFullSize() local _CXjU, h = self:GetSize() _CXjU = _CXjU or 0x1 h = h or 0x1 local _am1t, mx2, my1, my2 = self:GetBarMargin() return math.max(_CXjU - _am1t - mx2, 0x2), math.max(h - my1 - my2, 0x2) end function _mHUW:GetBarVirtualSize() local _dMMo, h = self:GetSize() _dMMo = _dMMo or 0x1 h = h or 0x1 local _m4KU, px2, py1, py2 = self:GetBarVirtualMargin() return math.max(_dMMo - _m4KU - px2, 0x0), math.max(h - py1 - py2, 0x0) end function _mHUW:SetTarget(_ViBM) self.target = _ViBM self:OnUpdate() end function _mHUW:SetWorldOffset(_G4OO) self.worldOffset = _G4OO self:OnUpdate() end function _mHUW:SetScreenOffset(_gkZt, _sOug) self.screen_offset.x = _gkZt self.screen_offset.y = _sOug self:OnUpdate() end function _mHUW:GetScreenOffset() return self.screen_offset.x, self.screen_offset.y end function _mHUW:OnUpdate(_nC75) _nC75 = _nC75 or 0x0 if self.target and self.target:IsValid() then if self.preUpdateFn then self.preUpdateFn(_nC75) end local _eBy8 = nil if self.target.AnimState then _eBy8 = Vector3(self.target.AnimState:GetSymbolPosition(self.symbol or "" , self.worldOffset.x, self.worldOffset.y, self.worldOffset.z)) else _eBy8 = self.target:GetPosition() end if _eBy8 then local _i93J = Vector3(TheSim:GetScreenPos(_eBy8:Get())) _i93J.x = _i93J.x + self.screen_offset.x _i93J.y = _i93J.y + self.screen_offset.y self:SetPosition(_i93J) end end if self.animOut and _nC75 > 0x0 then if math.abs(self.hbWidth - self.animHBWidth) < 0x3 then self.animOut = false self:SetHBSize(self.animHBWidth, self.hbHeight) self:Kill() return else self:SetHBSize(_PqNO(self.hbWidth, self.animHBWidth, self.animSpeed * _nC75), self.hbHeight) end elseif self.animIn and _nC75 > 0x0 then if math.abs(self.hbWidth - self.animHBWidth) < 0x1 then self.animIn = false self:SetHBSize(self.animHBWidth, self.hbHeight) else self:SetHBSize(_PqNO(self.hbWidth, self.animHBWidth, self.animSpeed * _nC75), self.hbHeight) end end local _l7Bw = self.healthReductions if #_l7Bw > 0x0 and _nC75 > 0x0 then for _hguC = #_l7Bw, 0x1, - 0x1 do local _u4tI = _l7Bw[_hguC] _u4tI.fadeTimer = _u4tI.fadeTimer - _nC75 if _u4tI.fadeTimer < 0x0 then table.remove(_l7Bw, _hguC) _u4tI:Kill() break end local _jFN0 = self.data and self.data.hrUseBarColor and self.barColor or self.hrColor _u4tI:SetTint(_jFN0.r, _jFN0.g, _jFN0.b, self.opacity * _u4tI.fadeTimer / self.hrDuration) end end if self.showValue and not self.text.shown then self.text:Show() elseif not self.showValue and self.text.shown then self.text:Hide() end local _wHay, sh = TheSim:GetScreenSize() if _wHay ~= self.screenWidth or sh ~= self.screenHeight then self.screenWidth = _wHay self.screenHeight = sh self:SetYOffSet() end if self.isDemo and self.dragging and _nC75 > 0x0 then local _sGbU = self:GetScale() local _6OPt, y = TheInput:GetScreenPosition():Get() local _TCDG = self:GetWorldPosition() local _beCj, barH = self:GetBarVirtualSize() _beCj = _beCj * _sGbU.x barH = barH * _sGbU.y local _SDml, oy = self:GetBarVirtualOffset() _SDml = _SDml * _sGbU.x oy = oy * _sGbU.y local _t1Vs = (_6OPt - (_TCDG.x + _SDml) + _beCj / 0x2) / _beCj self:SetPercentage(_t1Vs, true) if not self.focus then self.dragging = false end end end return _mHUW 